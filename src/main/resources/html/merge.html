<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Merge</title>
</head>
<body>
<p align="justify"><b>Сортировка слиянием (англ. merge sort)</b> - алгоритм сортировки, предложенный Джоном фон Нейманом
    в 1945 году. Это устойчивый алгоритм, использующий <b>O(n)</b> дополнительной памяти и работающий за <b>O(n log<sub>2</sub>
        (n))</b> времени.</p>
<h2 align="center"><b>Принцип работы</b></h2>
<p align="justify"> Алгоритм использует принцип разделяй и властвуй: задача разбивается на подзадачи меньшего размера,
    которые решаются по отдельности, после чего их решения комбинируются для получения решения исходной задачи.
    Конкретно процедуру сортировки слиянием можно описать следующим образом:</p>
<ol>
    <li>Если в рассматриваемом массиве один элемент, то он уже отсортирован, алгоритм завершает работую.</li>
    <li>Иначе массив разбивается на две части, которые сортируются рекурсивно.</li>
    <li>После сортировки двух частей массива к ним применяется процедура слияния, которая по двум отсортированным частям
        получает исходный отсортированный массив.
    </li>
</ol>
<h4 align="center"><b>Слияние двух массивов</b></h4>
<p align="justify">У нас есть два массива <b>a</b> и <b>b</b> (фактически это будут две части одного массива, но для
    удобства будем писать, что у нас просто два массива). Нам надо получить массив c размером <b>|a|</b> + <b>|b|</b>.
    Для этого можно применить процедуру слияния. Эта процедура заключается в том, что мы сравниваем элементы массивов
    (начиная с начала) и меньший из них записываем в финальный. И затем, в массиве у которого оказался меньший элемент,
    переходим к следующему элементу и сравниваем теперь его. В конце, если один из массивов закончился, мы просто
    дописываем в финальный другой массив. После мы наш финальный массив записываем заместо двух исходных и получаем
    отсортированный участок.</p>
<h2 align="center"><b>Время работы</b></h2>
<p align="justify">Чтобы оценить время работы этого алгоритма, составим рекуррентное соотношение. Пускай <b>T(n)</b>
    время сортировки массива длины <b>n</b>, тогда для сортировки слиянием справедливо <b>T(n)</b> = <b>2T(n / 2) +
        O(n)</b>, где:</p>
<p align="justify"><b>O(n)</b> - время, необходимое на то, чтобы слить два массива.</p>
<p align="justify">Распишем это соотношение:</p>
<p align="justify"><b>T(n)</b> = <b>2T(n/2) + O(n)</b> = <b>4T(n/4) + 2O(n)</b> = ... = <b>2<sup>k</sup>T(1) + kO(n)</b>.
</p>
<p align="justify">Осталось оценить <b>k</b>. Мы знаем, что <b>2<sup>k</sup></b> = <b>n</b>, а значит <b>k</b> =
    <b>log<sub>2</sub>(n)</b>. Уравнение примет вид <b>T(n)</b> = <b>nT(1) + log<sub>2</sub>(n O(n))</b>. Так как <b>T(1)</b>
    - константа, то <b>T(n)</b> = <b>O(n) + log<sub>2</sub> (n O(n))</b> = <b>O(n log<sub>2</sub> (n))</b>.</p>
<h2 align="center"><b>Сравнение с другими алгоритмами</b></h2>
<p align="justify">Достоинства:</p>
<ul>
    <li>устойчивая</li>
    <li>можно написать эффективную многопоточную сортировку слиянием</li>
    <li>сортировка данных, расположенных на периферийных устройствах и не вмещающихся в оперативную память</li>
</ul>
<p align="justify">Недостатки:</p>
<ul>
    <li>при любых входных данных время работы - <b>O(n log<sub>2</sub>(n))</b></li>
    <li>требуется дополнительно <b>O(n)</b> памяти, но можно модифицировать до <b>O(1)</b></li>
</ul>
</body>
</html>