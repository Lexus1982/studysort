<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Bubble</title>
</head>
<body>
<p align="justify"><b>Сортировка простыми обменами, сортировка пузырьком (англ. bubble sort)</b> - простой алгоритм
    сортировки. Для понимания и реализации этот алгоритм &mdash; простейший, но эффективен он лишь для небольших
    массивов. Сложность алгоритма: <b>O(n<sup>2</sup>)</b>. Алгоритм считается учебным и практически не применяется вне
    учебной литературы, вместо него на практике применяются более эффективные алгоритмы сортировки. В то же время метод
    сортировки обменами лежит в основе некоторых более совершенных алгоритмов, таких как шейкерная сортировка,
    пирамидальная сортировка и быстрая сортировка.</p>
<h2 align="center"><b>Алгоритм</b></h2>
<p align="justify">Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы
    последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по
    массиву повторяются <b>n-1</b> раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не
    нужны, что означает - массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший
    элемент массива ставится на своё место в конце массива рядом с предыдущим &laquo;наибольшим элементом&raquo;, а
    наименьший элемент перемещается на одну позицию к началу массива (&laquo;всплывает&raquo; до нужной позиции, как
    пузырёк в воде, отсюда и название алгоритма).</p>
<h2 align="center"><b>Реализация</b></h2>
<div>ЦИКЛ ДЛЯ J=1 ДО N-1 ШАГ 1</div>
<div style="margin-left: 40px">F=0</div>
<div style="margin-left: 40px">ЦИКЛ ДЛЯ I=1 ДО N-J ШАГ 1</div>
<div style="margin-left: 80px">ЕСЛИ A[I] &gt; A[I+1] ТО ОБМЕН A[I],A[I+1]:F=1</div>
<div style="margin-left: 40px">СЛЕДУЮЩЕЕ I</div>
<div style="margin-left: 40px">ЕСЛИ F=0 ТО ВЫХОД ИЗ ЦИКЛА</div>
<div>СЛЕДУЮЩЕЕ J</div>
<p align="justify">Особенность данного алгоритма заключается в следующем: после первого завершения
    внутреннего цикла максимальный элемент массива всегда находится на <b>n</b>-ой позиции. При втором проходе,
    следующий по значению максимальный элемент находится на <b>n - 1</b> месте. И так далее. Таким образом,
    на каждом следующем проходе число обрабатываемых элементов уменьшается на 1 и нет необходимости &laquo;обходить&raquo;
    весь массив от начала до конца каждый раз.</p>
<p align="justify">Так как подмассив из одного элемента не нуждается в сортировке, то для сортировки
    требуется делать не более <b>n - 1</b> итераций внешнего цикла. Поэтому в некоторых реализациях внешний цикл
    всегда выполняется ровно <b>n - 1</b> и не отслеживается, были или не были обмены на каждой итерации.</p>
<p align="justify">Введение индикатора (флажка <b>F</b>) действительно произошедших во внутреннем цикле
    обменов уменьшает число лишних проходов в случаях с частично отсортированными массивами на входе. Перед каждым
    проходом по внутреннему циклу флажок сбрасывается в <b>0</b>, а после действительно произошедшего обмена
    устанавливается в <b>1</b>. Если после выхода из внутреннего цикла флажок равен <b>0</b>, то обменов не было, то
    есть массив отсортирован и можно досрочно выйти из программы сортировки.</p>
<h2 align="center"><b>Сложность</b></h2>
<p align="justify">В данной сортировке выполняются всего два различных вида операции: сравнение элементов
    и их обмен. Поэтому время всего алгоритма <b>T</b> = <b>T<sub>1</sub></b> + <b>T<sub>2</sub></b>, где
    <b>T<sub>1</sub></b> - время, затрачиваемое на сравнение элементов, а <b>T<sub>2</sub></b> - время, за
    которое мы производим все необходимые обмены элементов.</p>
<p align="justify">Так как в алгоритме меняться местами могут только соседние элементы, то каждый обмен
    уменьшает количество инверсий на единицу. Следовательно, количество обменов равно количеству инверсий в исходном
    массиве вне зависимости от реализации сортировки. Максимальное количество инверсий содержится в массиве, элементы
    которого отсортированы по убыванию. Несложно посчитать, что количество инверсий в таком массиве <b>n(n - 1) / 2</b>.
    Получаем, что <b>T<sub>2</sub></b> = <b>O(n<sup>2</sup>)</b>.</p>
<p align="justify">В неоптимизированной реализации на каждой итерации внутреннего цикла производятся <b>n
    - 1</b> сравнений, а так как внутренний цикл запускается также <b>n - 1</b> раз, то за весь алгоритм сортировки
    производятся <b>(n - 1)<sup>2</sup></b> сравнений.</p>
<p align="justify">В оптимизированной версии точное количество сравнений зависит от исходного массива.
    Известно, что худший случай равен <b>n(n - 1) / 2</b>, а лучший - <b>n - 1</b>. Следовательно,
    <b>T<sub>1</sub></b> = <b>O(n<sup>2</sup>)</b>.</p>
<p align="justify">В итоге получаем <b>T</b> = <b>T<sub>1</sub> + T<sub>2</sub></b> = <b>O(n<sup>2</sup>) +
    O(n<sup>2</sup>)</b> = <b>O(n<sup>2</sup>)</b>.
</p>
</body>
</html>